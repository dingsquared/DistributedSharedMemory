/* This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */
#define _GNU_SOURCE
#include <fcntl.h>
#include <signal.h>
#include <stdio.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/shm.h>
//#define __USE_GNU
#include <ucontext.h>
#include <unistd.h>
//#include <sys/ucontext.h>
#include <unistd.h>
#include <string.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <net/if.h>
#include <unistd.h>
#include <arpa/inet.h>
#include "psu_dsm_msg.h"
#include "psu_dsm_msg_svc.h"
#include "util.h"
#include "psu_dsm.h"

void segv_handler (int signum, siginfo_t *info, void *ucontext)
{
	printf("Recieved signal %d\n", signum);
	printf("ucontext = %p\n", ucontext);
//	printf("dsm.addr = %p\n", dsm.addr);
	printf("fault addr = %p\n", info->si_addr);
	if( ((ucontext_t *)ucontext)->uc_mcontext.gregs[REG_ERR] & 0x2){
		// write fault
		printf("\nwrite fault\n");
	}
	else{
		//read fault
		printf("\nwrite fault\n");
	}
	
//	mprotect (dsm.addr, PAGESIZE, PROT_READ | PROT_WRITE); 
}

/* Install segv_handler as the handler for SIGSEGV. */
void psu_dsm_init(){
	int fd;
	struct sigaction sa;
 	memset (&sa, 0, sizeof (sa));
 	sa.sa_sigaction = &segv_handler;
	sa.sa_flags = SA_SIGINFO;
 	sigaction (SIGSEGV, &sa, NULL);
}


psu_dsm_ptr_t
psu_dsm_malloc(char *name, int size){

	pageid_t page;
	strncpy(page.name, name, NAME_LEN);
	page.size = size;

	CLIENT *clnt;
	int  *result_1;
	char host[IP_LEN];
	get_local_ipaddr(host);

	clnt = clnt_create (host, PSU_DSM, PSU_DSM_VERS, "tcp");
	if (clnt == NULL) {
		printf("ERROR_HOST\n");
		clnt_pcreateerror (host);
		exit (1);
	}
	result_1 = psu_dsm_page_creat_1(&page, clnt);
	if (result_1 == (int *) NULL) {
		
		printf("error happened here!\n");
		clnt_perror (clnt, "call failed");
	}

#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */

	if(*result_1 != 1){
		perror("creat failed");
		exit(1);
	}

	
	key_t key;
	int shmid;

	key = hash(name);
	shmid = shmget(key, PAGE_SIZE, 0666);

	if(shmid == -1){
		perror("shmget\n");
		exit(1);
	}

	void *addr = shmat(shmid, (void *)0, 0);
	return addr;

	


// use shmget to get pointer
#if 0	
   	if(*result_1 != 1){
		perror("dsm_malloc failed!\n");
		exit(1);
	}
	
#if 0
 /* Allocate one page of memory by mapping /dev/zero. Map the memory
 *    as write-only, initially. */
 	int fd = open ("/dev/zero", O_RDONLY);
 	dsm.addr = mmap (NULL, PAGESIZE, PROT_WRITE, MAP_PRIVATE, fd, 0);
 	close (fd);
 /* Make the memory unwritable. */
 	mprotect (dsm.addr, PAGESIZE, PROT_NONE);
	dsm.size = size;
	strncpy(dsm.name, name, MAXNAME);
	return dsm.addr;
#endif

	key_t key;
	int shmid;

	key = hash(name);
	printf("key = %d\n", key);	
	shmid = shmget(key, PAGE_SIZE, 0644 | IPC_CREAT);

	if(shmid == -1){
		perror("shmget\n");
		exit(1);
	}

	//dsm.addr = shmat(shmid, (void *)0, 0);
	//if(dsm.addr == (char *)(-1)){
//		perror("shmat\n");
//		exit(1);
//	}
 	//mprotect (dsm.addr, PAGESIZE, PROT_NONE);
	
	//dsm.size = size;
	//strncpy(dsm.name, name, NAME_LEN);
	//return dsm.addr;
#endif
}

